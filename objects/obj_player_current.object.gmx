<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_current</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-800</depth>
  <persistent>0</persistent>
  <parentName>parent_player</parentName>
  <maskName>spr_player_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
event_inherited() // inherit the variables that both the current and the clone object share

player_speed_x = 0
player_speed_y = 0

SpeedX = 0
SpeedY = 0

max_speed = 8
accel = 0.4

can_shoot = true
reload_time = 20
player_sight = 200 // distance before seeing and auto shooting an enemy

FOOTSTEP_TIME = 5
alarm[0] = FOOTSTEP_TIME // create a "footstep"

instance_create(x,y,obj_hud_life_bar) // deleted when player dies

vstick[1,8] = 0 // reset the angle of the vstick

/// initialise movement keys
move_left = false
move_right = false
move_up = false
move_down = false
move_attack = false

has_fired = false
target_locked = false // show red rectile when auto-targeting
target_enemy = 0 // used for auto-targeting

image_angle2 = 0 // RECORDED (didn't use image_angle because it also changes the collision box, causing wall sticking etc)

show_death_message = true // onlycreate message when player dies normally. not when next iteration was pressed 

obj_controller_playable.PLAYER_LIVES -= 1

// increment player count
global.player_number += 1
number = global.player_number

// add this object to the array list
global.player_array[global.player_number] = self

// create a recorder object to record this play through
instance_create(x,y,obj_player_recorder)
obj_player_recorder.player = id


// create the virtual joysticks!
if !instance_exists(obj_virtual_joystick) 
{
    vj = instance_create(x,y,obj_virtual_joystick)
    vj.player = id
} 
else
{ obj_virtual_joystick.player = id } // if object already exists, assign the new object ID

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// create dead object

obj_player_recorder.life_span = global.counter // set the recorders lifespan

instance_destroy(obj_hud_life_bar)
instance_destroy(obj_virtual_joystick) // destroy both joysticks

print_debug('player_lives ==== ' +string(obj_controller_playable.PLAYER_LIVES))

if obj_controller_playable.PLAYER_LIVES == 0 { instance_destroy(obj_hud_next_player) }

if (show_death_message)
{
    instance_destroy(obj_hud_next_player) // hide next player button since death message is basically the same
    instance_create(WIDTH/2, HEIGHT/2, obj_message_level_failed)
}

print_debug("------ Current player died at "+string(global.counter)+" ------")

// dead body
instance_create(x,y,obj_player_dead)

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///can_shoot = true
can_shoot = true
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// footsteps!

//if x != xprevious

    //if y != yprevious
    
        //instance_create(x,y,obj_footstep) // create a footstep
    


alarm[0] = FOOTSTEP_TIME // repeat
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_camera()

scr_camera()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// movement (scr_controls)

scr_controls()

if hp &lt;= 0 { instance_destroy() }


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_portal_send">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
x = obj_portal_recieve.x
y = obj_portal_recieve.y

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// using the built in image_angle variable will affect the collision box, don't use it otherwise you may stick to walls etc.
// this manually sets the image_angle2 to only range from 0-360 just like the normal image_angle
if image_angle2 &gt;= 360 {image_angle2 = 0}
if image_angle2 &lt; 0 {image_angle2 = 360}

// player direction - mouse/joystick
dir = vstick_get_direction(1)
if global.auto_target == true { scr_auto_shoot_enemy() } // auto target

if global.instant_aim 
{image_angle2 = dir} // no aim delay from the virtual stick
else
{image_angle2 = (image_angle2+(sin(degtorad(dir-image_angle2)) * 12))} // 12 = reaction time

//image_angle2 = point_direction(xprevious,yprevious,x,y) // point the way you're walking
// dir = point_direction(x,y,mouse_x,mouse_y) // windows version - point to mouse

x = round(x)
y = round(y)

// draw the write pointer if the player is currently playing
draw_sprite_ext(spr_pointer,0,x+lengthdir_x(len-12,image_angle2),y+lengthdir_y(len-12,image_angle2),image_xscale,image_yscale,image_angle2,image_blend,image_alpha)

// draw recticle
if target_locked
{ draw_sprite(spr_reticle, 1, target_enemy.x, target_enemy.y) }
else
{ draw_sprite_ext(spr_reticle,0,x+lengthdir_x(len+player_sight,image_angle2),y+lengthdir_y(len+player_sight,image_angle2),image_xscale,image_yscale,0,image_blend,image_alpha) }

draw_self()

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

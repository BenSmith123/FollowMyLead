<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_recorded</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>parent_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Remember: if you want the variable to be reset for an iteration, add it to event_user0

event_inherited() // inherit the variables that both the current and the clone object share

is_recording = true
is_alive = false

life_span = 0 // set by obj_player_current

image_angle2 = 0 // fix?

// initialise the array counts
array_shoot_count = 0
array_x_count = 0
array_y_count = 0
array_angle_count = 0

array_shoot[0] = 0 // start the array at 0
// ^^ 0 is reserved for the first shot (0 difference between the first shot and the shot before that as their is no shot before that)

//array_x[0] = 0


//alarm[0] = 1 // this starts all the recorded arrays off! Has to be called here!




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// RECORDING: SHOOTING
if is_alive == false {exit}

// has to be different from calling the shoot script because the reload/canshoot etc.
idd = instance_create(x+lengthdir_x(len,image_angle2),y+lengthdir_y(len,image_angle2),obj_bullet_player)
idd.direction = image_angle2
idd.image_angle = image_angle2
idd.speed = bullet_speed

global.error_msg = global.counter

if array_shoot_count &lt; array_length_1d(array_shoot)-1 // if the array has not reached the end (minus 1 because of array index 0)
{
    array_shoot_count++ // avoid 0 in the array
    alarm[1] = array_shoot[array_shoot_count] // reset the alarm for the next time a bullet was fired
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// lifespan over, is_alive = false

is_alive = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// HP, death and recording

if is_recording == true
{
    //is_alive = false
    
    if instance_exists(player)
    {
        if player.has_fired == true
        {
            array_shoot_count++ // increment before shooting, first shot = 1, second = 2 etc.
            array_shoot[array_shoot_count] = global.counter - array_shoot[array_shoot_count-1] // stores the time the bullet was fired minus the last time a bullet was shot
            global.error_msg = global.counter
            player.has_fired = false
        }
        
        if player.xprevious != player.x // if the player has moved x position, increment the array and get the x_position
        {
            array_x_count++
            array_x[global.counter] = player.x// global.counter - array_x[array_x_count-1]
            
            // if the player wasn't moving but now is, save the time that the player wasn't moving til now 
            if stored_x == true
            {
                array_x_inactive[x_num] = global.counter - stored_x
                stored_x = false
            }
        }
        else
        {
            if stored_x == false // stops timer from constantly getting the global.timer
            {
                last_move_x = global.counter // get the time the player stopped moving
                stored_x = true
            }
        }
        
        // set the x/y position to the values stored in the array (values recorded)
        //player.x = array_x[global.counter]
        //player.y = array_y[global.counter]
        //player.image_angle2 = array_angle[global.counter] // angle the recorded player
        
        // create bullet when the recorded player fired a shot
        //if array_shoot[global.counter] == true {shoot()}
    }
}
else
{
    if hp &lt;= 0 {is_alive = false}
    
    // now handled by event_user0: if global.counter == life_span {is_alive = false} // die if the recording has ended
    
    if is_alive == true
    {
        if array_x_count &lt;= array_length_1d(array_x)+1
        {
            if array_x[global.counter] != 0
            {x = array_x[global.counter]}
        }
    }
    else
    {
        sprite_index = spr_player_dead
        hspeed = 0
        vspeed = 0
        depth = 220 // change the depth to behind AI etc
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// RESET VARIABLES FOR ITERATION

x = xstart
y = ystart

hp = max_hp

array_shoot_count = 0 // this can be reset because it counts the amount of times a bullet is fired for both recording and re-using

is_recording = false
is_alive = true

alarm[0] = life_span // start the countdown til dead

sprite_index = spr_player_recorded


// begin the recording system alarms!

if array_shoot_count != array_length_1d(array_shoot)-1 // if the array has not reached the end
{
    array_shoot_count++ // avoid 0 in the array
    alarm[1] = array_shoot[array_shoot_count]-1 // reset the alarm for the FIRST time a bullet was fired
    // the -1 will remove the delay from calling this alarm 1/60th of a second late
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// if this object is the one currently recording the obj_player_current object, don't draw anything
if is_recording == false
{
    
    if is_alive == true
    {
        // draw the arrow of a recorded player
        draw_sprite_ext(spr_arrow,0,x+lengthdir_x(len-12,image_angle2),y+lengthdir_y(len-12,image_angle2),image_xscale,image_yscale,image_angle2,image_blend,image_alpha)
    }
    
    draw_self()

        /**** old recording stuff
        if stop_counter = false {counter += 1} // stop counter if player walks into wall
    
        // set the x/y position to the values stored in the array (values recorded)
        x = array_x[counter]
        y = array_y[counter]
        image_angle2 = array_angle[counter] // angle the recorded player
        
        // create bullet when the recorded player fired a shot
        if array_shoot[counter] == true {shoot()}
        ************/

}

// debug shit

draw_sprite(spr_turret_barrel,0,x,y)

draw_text(x,y,"record: " +string(is_recording))
draw_text(x,y+16,"alive: " +string(is_alive))


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///event_user0
event_user(0) // reset variables!

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

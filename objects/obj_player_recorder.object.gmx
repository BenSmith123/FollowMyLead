<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialise

//is_recording = true // stop recording when player dies

player = 0 // set by obj_player_current

life_span = 0 // also array size

last_shoot_time = 0
array_shoot_count = 0 // size of the shooting array

// recording of the player angle
last_move_angle_time = 0 // the last time the angle had changed (move or stop)
stored_angle = true
last_player_angle = 0
angle_count = 0 // size of the angle array
angle_inactive_count = 0 // size of the inactive angle array

// recording of X variables
x_num = 1 // size of the x_switch array - start at 1 as 0 is reserved for first array index
stored_x = true // temp variable for when x was stored
last_move_x = 0 // the time that the players x last moved
array_x_count = 0 // size of the actual x movement array
array_x_inactive[0] = 0

// recording of Y variables
y_num = 1
stored_y = true
last_move_y = 0
array_y_count = 0
array_y_inactive[0] = 0



// ARRAYS: 

array_shoot[0] = 0 // start the array at 0
// ^^ 0 is reserved for the first shot (0 difference between the first shot and the shot before that as their is no shot before that)



/*
array_shoot = 0
array_x = 0
array_x_pause = 0
array_y = 0
array_y_pause = 0
array_angle = 0
array_angle_pause = 0


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEBUG: console output

if global.debug_array_output
{
    show_debug_message("------ "+string(id)+" ------") 
    show_debug_message("x_size: "+string(x_num))
    show_debug_message("x_inactive_size: "+string(array_x_count))
    show_debug_message("y_size: "+string(y_num))
    show_debug_message("y_inactive_size: "+string(array_y_count))
    show_debug_message("angle_count: "+string(angle_count))
    show_debug_message("angle_inactive_size: "+string(angle_inactive_count))
    show_debug_message("shoot_size: "+string(array_shoot_count))
    
    debug_output = "------ "+string(id)+" ------ 
    x_size: "+string(x_num)+"\n
    x_inactive_size: "+string(array_x_count)+"\n
    
    y_size: "+string(y_num)+"##
    y_inactive_size: "+string(array_y_count)+"
    
    angle_size: "+string(angle_count)+"
    angle_inactive_size: "+string(angle_inactive_count)+"
    
    shoot_size: "+string(array_shoot_count)
    
    show_message_async(debug_output)
    
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// RECORDING

if instance_exists(player)
{

    // RECORD SHOOTING
    if player.has_fired == true
    {
        array_shoot_count++ // increment before shooting, first shot = 1, second = 2 etc.
        array_shoot[array_shoot_count] = global.counter - last_shoot_time//array_shoot[array_shoot_count-1] // stores the time the bullet was fired minus the last time a bullet was shot
        
        player.has_fired = false
        last_shoot_time = global.counter
    }
    
    
    // RECORD ANGLE
    if last_player_angle != round(player.image_angle2) // if the player angle has changed
    {
        if stored_angle == true
        {
            array_angle_inactive[angle_inactive_count] = global.counter - last_move_angle_time
            angle_inactive_count++
            
            last_move_angle_time = global.counter
            
            print_debug("(R) Angle moved at " +string(global.counter))
            
            stored_angle = false
        }
        
        // RECORD
        array_angle[angle_count] = round(player.image_angle2) // record the angle
        angle_count++
        
        last_player_angle = round(player.image_angle2)
        
    }
    else if stored_angle == false
    {
        array_angle_inactive[angle_inactive_count] = global.counter - last_move_angle_time
        angle_inactive_count++
        
        print_debug("(R) Angle stopped at " +string(global.counter))
        
        last_move_angle_time = global.counter
        stored_angle = true
    }
    
    
    
    // RECORD X MOVEMENT
    if round(player.xprevious) != round(player.x) // if the player has moved x position, increment the array and get the x_position
    // ^^ has to be rounded otherwise the array size will increase because of the decimal values
    {
        // if the player wasn't moving but now is, save the time that the player wasn't moving til now
        if stored_x == true
        {
            array_x_inactive[x_num] = global.counter - last_move_x // get the time between now (started moving) and the last time the player stopped moving
            //array_x_inactive[x_num] = global.counter - array_x_inactive[x_num-1] // somehow this doesn't work
            //print_debug("moved at " +string(global.counter))
            x_num++
            
            last_move_x = global.counter // save the last time player moved
            stored_x = false
        }
        
        // RECORD
        array_x_count++
        array_x[array_x_count] = round(player.x)
    }
    else if stored_x == false // stops timer from constantly getting the global.timer
    {
        array_x_inactive[x_num] = global.counter - last_move_x
        //print_debug("stopped at " +string(global.counter))
        
        //create an object here then make the clone do the same, see if position matches
        
        x_num++
        last_move_x = global.counter // save the last time player stopped
        stored_x = true
    }
    
    
    
    // RECORD Y MOVEMENT
    if round(player.yprevious) != round(player.y)
    {
        if stored_y == true
        {
            array_y_inactive[y_num] = global.counter - last_move_y

            //print_debug("(R) moved at " +string(global.counter))
            y_num++
            
            last_move_y = global.counter
            stored_y = false
        }
        
        // RECORD
        array_y_count++
        array_y[array_y_count] = round(player.y)
    }
    else if stored_y == false // stops timer from constantly getting the global.timer
    {
        array_y_inactive[y_num] = global.counter - last_move_y
        
        //print_debug("(R) stopped at " +string(global.counter))
        y_num++
        last_move_y = global.counter // save the last time player stopped
        stored_y = true
    }
    
    
} 


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// NEW ITERATION! Create new clone

// loop through all the arrays


if instance_exists(obj_player_current) // if the player is still alive when next iteration is pressed
{life_span = global.counter} // set lifespan to this iterations counter 

// create the clone where the current_player started
clone = instance_create(xstart,ystart,obj_player_clone)

global.player_array[global.player_number] = clone // override the current player (that just died) with the new clone object

clone.life_span = life_span-1
clone.alarm[0] = life_span-1

// start the clone firing array if there was atleast one bullet fired
if array_shoot_count &gt; 0
{
    clone.alarm[1] = array_shoot[1]-1 // the -1 makes the x movement exact
}

//clone.array_shoot_count = array_shoot_count



// loop through the arrays and copy all variables to clone object

// SHOOTING
for(i = 0; i &lt;= array_shoot_count; i++)
{clone.array_shoot[i] = array_shoot[i]}


// ARRAY ANGLE
if angle_count != 0 // stops from crashing if player angle never changed
{
    for(i = 0; i &lt; angle_count; i++)
    {clone.array_angle[i] = array_angle[i]}

    for(i = 0; i &lt; angle_inactive_count; i++)
    {clone.array_angle_inactive[i] = array_angle_inactive[i]}

    clone.alarm[4] = array_angle_inactive[0]-1 // start the countdown until movement
}

// X MOVEMENT
if array_x_count != 0 // stops from crashing if player x didn't move
{
    // send the player_x position
    for(i = 0; i &lt;= array_x_count; i++)
    {clone.array_x[i] = array_x[i]}
    
    // send the x switch array (moving/not moving)
    for(i = 0; i &lt; x_num; i++)
    {clone.array_x_inactive[i] = array_x_inactive[i]}
    
    //clone.x_inactive_size = x_num // pass the size of the array - not needed because array_size_1d can get the size

    if array_x_count &gt; 0
    {clone.alarm[2] = array_x_inactive[1]-1} // start the countdown until movement
}

// Y MOVEMENT
if array_y_count != 0
{
    for(i = 0; i &lt;= array_y_count; i++)
    {clone.array_y[i] = array_y[i]}
    
    for(i = 0; i &lt; y_num; i++)
    {clone.array_y_inactive[i] = array_y_inactive[i]}

    if array_y_count &gt; 0
    {clone.alarm[3] = array_y_inactive[1]-1} // start the countdown until movement
}


instance_destroy()

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
